
  
  
  

  No-Panic Rust: A Nice Technique for Systems Programming
  

  
  
  
  

  
  
  
  

  
  
  

  
  
  
  
  




  
    
    
    

     

   

    <a href="/">Josh Haberman</a>

     
        <a href="/about/">About</a>
     

   

 


     
       
         

   
     No-Panic Rust: A Nice Technique for Systems Programming 
    <p>
      
      <time datetime="2025-02-03T00:00:00+00:00">February 3, 2025</time>
    </p>
   

   
    <p>Can Rust replace C? This is a question that has been on my mind for many years,
as I created and now am tech lead for
<a href="https://github.com/protocolbuffers/protobuf/tree/main/upb">upb</a>, a C library
for Protocol Buffers.  There is an understandable push to bring memory safety
  to all
parts of the software stack, and this would suggest a port of upb to Rust.</p>

<p>While I love the premise of Rust, I have long been skeptical that a port of upb
to Rust could preserve the performance and code size characteristics that I and
others have fought so hard to optimize.  In fact, this blog entry was
originally going to be an argument for why Rust cannot match C for upb’s use
case.</p>

<p>But I recently discovered a technique that shifted my thinking a lot.  I call
it “No-Panic Rust”, and while the technique is clearly not new<sup><a>1</a></sup>, I was not
able to find any in-depth discussion of how it works or what problems it
solves.  This article is my attempt to fill that gap.</p>

<p>I believe that No-Panic Rust is the key to making Rust a compelling option for
low-level systems programming.  I now am optimistic about the possibility of
porting upb to Rust.</p>

 What are Panics? 

<p>Panics are Rust’s mechanism for <em>unrecoverable errors</em>.  Anytime our program
encounters an error, we have three basic options for how to handle it:</p>

<ol>
  <li>Handle the error immediately (eg. retry the operation or fall back to plan B).</li>
  <li>Propagate the error to the caller, who can decide how to handle it.</li>
  <li>Immediately abort execution.</li>
</ol>

<p>In Rust, we use <code>Result</code> for (2) and <code>panic!()</code> for (3).  When we use <code>Result</code>,
it is considered a “recoverable error”, because the caller can test for the
error and decide how to respond.</p>

<p>With recoverable errors, the potential for error is reflected in the function
signature; a function that returns <code>Result</code> is fallible from the perspective of
the caller.  Panics on the other hand present the illusion of infallibility
from an API perspective, but then proceed to handle errors by simply aborting.</p>

<p>There is a lot of standard guidance for when to use <code>panic!()</code> vs <code>Result</code> (for
example,
<a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html">here</a>
and
<a href="https://doc.rust-lang.org/std/macro.panic.html#when-to-use-panic-vs-result">here</a>),
which largely boils down to the idea that panics should only be used for bugs
in the code.  I especially like the framing given in <a href="https://www.reddit.com/r/rust/comments/9x17hn/comment/e9p5c9t/">this Reddit post</a>:</p>

<blockquote>
  <p>[If] your <strong>library</strong> is the source of a panic, then one of the following
should be true:</p>

  <ul>
    <li>
      <p>Your library has a bug.</p>
    </li>
    <li>
      <p>Your library documents a precondition of a public API item that, when not
met, causes a panic. Therefore, the user of your library has misused your
library, and their code has a bug.</p>
    </li>
  </ul>

  <p>If your Rust <strong>application</strong> panics in response to any user input, then the
following should be true: your application has a bug, whether it be in a
library or in the primary application code.</p>
</blockquote>

<p>In this article we are focused on the library case.</p>

 Why Are Panics Bad For Systems Libraries? 

<p>If we are trying to port a C library to Rust, we really do not want to
introduce panics in the code, even for unusual error conditions.  They cause
many practical problems:</p>

<ol>
  <li><strong>Code Size:</strong> The runtime to handle a panic pulls in about 300Kb of code.<sup><a>2</a></sup>
We pay this cost if even a single <code>panic!()</code> is reachable in the code.
From a code size perspective, this is a severe overhead, given that the upb
core is only 30Kb.</li>
  <li><strong>Unrecoverable exit:</strong> If a panic is triggered, it takes down the
entire process.<sup><a>3</a></sup>  In many applications, this is a severe failure mode
that libraries should never invoke.  Instead, we should return all errors
to the caller using status codes.</li>
  <li><strong>Runtime overhead:</strong> A potential panic implies some kind of runtime check.
In many cases, the cost of this check will be minimal, but for very small
and frequently invoked operations, the cost of this check could be
significant.</li>
</ol>

<p>In the case of upb, I was concerned about all three of these factors.  Ideally
we could port upb to Rust without users even noticing.  To do that, we want to
maintain the same performance, code size footprint, and error reporting
behavior that the C code has now.  Panics get in the way of this ideal.</p>

<p>At some point I realized that it might be possible to ban panics from the
library entirely, which would solve all of these problems at once.  That is
when I started getting much more optimistic about porting upb to Rust.</p>

 What is No-Panic Rust? 

<p>No-Panic Rust is a subset of Rust for which <code>panic!()</code> is unreachable.
Programs written in no-panic Rust are guaranteed never to panic under any
circumstances.</p>

<p>For a library, this means we should be able to build a <code>cdylib</code> that does
not have a panic handler linked into it at all.<sup><a>4</a></sup></p>

<p>We can experiment on <a href="https://godbolt.org">godbolt.org</a>
to see if we have succeeded or not.  Using my tool <a href="https://github.com/google/bloaty">Bloaty</a>,
we can see if the <code>cdylib</code> binary is &gt;300Kb (suggesting that the panic
handler has been linked in) or &lt;10Ki (suggesting it has not).<sup><a>5</a></sup></p>

<p>Let’s explore this subset a bit.  Is “Hello, World” no-panic?</p>

  <pre><code>#[no_mangle]
pub extern "C" fn hello_world() {
    println!("Hello, World!")    // Can panic
}
</code></pre>  

<p>No, per <a href="https://doc.rust-lang.org/std/macro.println.html#panics">the documentation for <code>println!()</code></a>:</p>

<blockquote>
  <p>Panics if writing to <code>io::stdout</code> fails.</p>
</blockquote>

<p>And indeed, if we try this on Godbolt, we see a big binary:</p>



<p>So <code>println!()</code> is out.  If we want to print to stdout, we’ll need to use an API
that does not advertise that panic is possible.</p>

<p>The <a href="https://doc.rust-lang.org/beta/std/io/fn.stdout.html"><code>stdout</code></a> API looks
promising, because it has a <code>write_all()</code> API that returns a <code>Result</code>, which
should allow us to handle errors explicitly:</p>

  <pre><code>use std::io::{self, Write};

#[no_mangle]
pub extern "C" fn hello_world() -&gt; bool {
    let result = io::stdout().write_all(b"Hello, World!\n");
    match result {
        Ok(_) =&gt; true,
        Err(_) =&gt; false,
    }
}
</code></pre>  

<p>This seems like it should be no-panic.  We are only calling two APIs,
<a href="https://doc.rust-lang.org/beta/std/io/fn.stdout.html"><code>stdout()</code></a> and
<a href="https://doc.rust-lang.org/beta/std/io/struct.Stdout.html#method.write_all-1"><code>write_all()</code></a>,
neither of which documents a potential panic.</p>

<p>But if we try it, we’ll see that panic is indeed reachable in this program
somehow.</p>



<p>From this we have learned that we unfortunately cannot rely on panic
annotations in API documentation to determine <em>a priori</em> whether some Rust code
is no-panic or not.  We have to actually try it and observe the results.</p>

<p>How can we diagnose what went wrong?  On macOS, the linker has a very handy
option called <code>-why_live</code>, which will print the chain of symbol references
that prevented a symbol from being dead-stripped.  We can’t access it on Godbolt
unfortunately, but on macOS we can run this command:</p>

  <pre><code>$ RUSTC_LOG=rustc_codegen_ssa::back::link=info \
  RUSTFLAGS="-C link-arg=-Wl,-why_live,_rust_panic" \
  cargo build --release 2&gt;&amp;1 | rustfilt
</code></pre>  

<p>This results in the following output, with extraneous details removed:</p>

  <pre><code>_core::panicking::panic from [...]
  _core::ops::function::FnOnce::call_once from [...]
    l_anon.56b0c16dbe4596c74313e318a3dfaa78.520 from [...]
      _std::sync::once_lock::OnceLock&lt;T&gt;::initialize from [...]
        _std::io::stdio::stdout from [...]
          _hello_world from [...]
</code></pre>  

<p>The panic reference apparently comes from
<code>_core::ops::function::FnOnce::call_once</code>, which is called
from <code>_std::io::stdio::stdout</code>.</p>

<p>This seems to suggest that Rust’s standard library does not meet the criteria
given <a href="#what-are-panics">above</a>, because it is capable of panicing even in APIs
like <code>std::io::stdout()</code> that do not document a panic-worthy precondition.</p>

<p>This also implies that we need tests that check for the no-panic property.
It’s not enough to check once that the code is no-panic, we need to make sure
it <em>stays</em> no-panic over time, even as our project and our dependendencies
evolve.</p>

<p>To get a fully no-panic version of “Hello, World”, we have to reach for the C
library <code>libc</code>.  This makes sense, since the C library is generally written to
return all errors as status codes or <code>errno</code>.  Unfortunately this means turning
to <code>unsafe</code>:</p>

  <pre><code>extern crate libc;

#[no_mangle]
pub extern "C" fn hello_world() -&gt; bool {
    const MSG: &amp;'static str = "Hello, World!\n\0";
    let result = unsafe {
        libc::printf(MSG.as_ptr() as *const _)
    };
    result &gt;= 0
}
</code></pre>  

<p>And checking on Godbolt, we see the small binary that confirms that this
library is indeed no-panic:</p>



 Opt No-Panic 

<p>What about adding two numbers?  Is this no-panic?</p>

  <pre><code>#[no_mangle]
pub extern "C" fn hello_world(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>  

<p>This is a trick question: this is no-panic in opt mode only.  For numeric
operations like addition, Rust introduces overflow checks (which panic on
failure) in debug mode, but leaves them out of opt builds.</p>

<p>We can observe this on Godbolt if we add separate panes for opt and non-opt
builds:<sup><a>6</a></sup></p>



<p>This essentially creates a new class of code, which is “no-panic in opt, but
can panic in dbg”.</p>

<p>For the case of upb, this seems like a great option, because it gives us extra
consistency checks in debug mode without suffering the problems of panic in
release builds.  It is essentially the Rust equivalent of <code>assert()</code> in C.
Overflow by itself does not represent a safety issue, so we are not giving up
safety by leaving the panics out of opt builds.</p>

 Rust’s Standard Library 

<p>What about using standard containers like <code>Vec</code>?</p>

  <pre><code>use std::hint::black_box;

#[no_mangle]
pub extern "C" fn hello_world() {
    let vec: Vec&lt;u32&gt; = Vec::new();
    black_box(vec);
}
</code></pre>  

<p>It turns out this is also “opt no-panic” code (perhaps <code>Vec</code> is internally
performing some arithmetic which can overflow):</p>



<p>But once we try to actually push elements into the <code>Vec</code>, we’re squarely out
of no-panic Rust:</p>



<p><code>Vec</code> does have a few APIs that will surface allocation errors instead of panicking.
Theoretically, this code should be no-panic:</p>

  <pre><code>#![feature(vec_push_within_capacity)]

use std::hint::black_box;

#[no_mangle]
pub extern "C" fn hello_world() -&gt; bool {
    let mut vec: Vec&lt;u32&gt; = Vec::new();
    if !vec.try_reserve(1).is_ok() {
        return false;
    }
    if !vec.push_within_capacity(1).is_ok() {
        return false;
    }
    black_box(vec);
    true
}
</code></pre>  

<p>This requires the nightly compiler, but I was able to make this work as no-panic
on macOS.  For some reason, it did not work with the nightly compiler on Godbolt,
which appears to always include the panic runtime no matter what I do, even for a
trivial library.  I was not able to figure out why.</p>

<p>The Rust standard library was not really designed to be no-panic.  For example,
memory allocation failure will panic in most cases.  If we want to be no-panic,
we will probably have to avoid most of the standard library.  Realisticaly we
will probably want to go fully <code>#![no_std]</code>.</p>

 A Dance With The Optimizer 

<p>Here is another trick question: is this no-panic Rust?</p>

  <pre><code>#[no_mangle]
pub extern "C" fn hello_world(data: &amp;[u8]) -&gt; u8 {
    if data.len() &lt; 1 {
        return 0;
    }
    data[0]
}
</code></pre>  

<p>On one hand, the slice index operation <a href="https://doc.rust-lang.org/std/ops/trait.Index.html#tymethod.index">clearly
documents</a>
that it may panic.  On the other hand, the docs say that this panic will only
be triggered if the index is out of bounds, and we have inserted a guard to
ensure that it never is.  So is the panic reachable?</p>

<p>If we use our minds to reason about the code, we would conclude that panic is
unreachable.  The compiler is capable of reaching the same conclusion, but only
if we run the optimizer, which can prove through a series of optimizations that
the bounds check will never fail.</p>

<p>So this example ends up being “opt no-panic”, just like our arithmetic
operation, but for an entirely different reason!</p>



<p>This is quite an interesting result that totally changed my thinking about
Rust’s bounds checks.</p>

<p>My previous perspective was that Rust will insert all of these unnecessary
bounds checks, bloating the code and slowing it down for no reason.  But our
pre-existing C code is not throwing caution to the wind and hoping for the
best.  Every place that we perform an index operation in C, it’s because we
believe we have a proof that the index is in bounds.  To avoid the bounds
checks in Rust, we just need to express this proof in a way that the Rust
optimizer can understand.  This is what I call the “dance with the optimizer.”</p>

 A Slightly More Dangerous Dance 

<p>In the example above, the bounds check is eliminated using only safe code,
but there are other cases where we might need to use unsafe code to help
the optimizer know about program invariants that cannot be easily derived
from the program flow.</p>

<p>For example, consider this (admittedly contrived) program:</p>

  <pre><code>pub struct S&lt;'a&gt; {
    data: &amp;'a[u8],
    ofs: usize,   // Invariant: ofs &lt; data.len()
}

impl&lt;'a&gt; S&lt;'a&gt; {
    pub fn new(data: &amp;[u8]) -&gt; Option&lt;S&gt; {
        match data.len() {
            0 =&gt; None,
            n =&gt; Some(S{data: data, ofs: n - 1}),
        }
    }

    pub fn get(&amp;self) -&gt; u8 {
        self.data[self.ofs]
    }
}

#[no_mangle]
pub extern "C" fn hello_world(s: &amp;S) -&gt; u8 {
    s.get()
}
</code></pre>  

<p>In this program, our struct <code>S</code> has an invariant that the offset <code>S::ofs</code> will
always be in bounds.  This invariant effectively guarantees that the bounds
check in <code>S::get()</code> will never fail.  And we can strongly guarantee that the
invariant holds, because it is enforced by our <code>new()</code> function which is the
only code that sets these struct members.</p>

<p>But the optimizer isn’t capable of reasoning at this level, so it thinks that
the panic is reachable, and keeps the bounds check in the program, even in opt
mode:</p>



<p>To make this no-panic, we need to help the compiler out by reminding it that
this struct invariant holds in the critical path:</p>

  <pre><code>use std::hint::assert_unchecked;

pub struct S&lt;'a&gt; {
    data: &amp;'a[u8],
    ofs: usize,   // Invariant: ofs &lt; data.len()
}

impl&lt;'a&gt; S&lt;'a&gt; {
    fn check_invariant(&amp;self) {
        unsafe { assert_unchecked(self.ofs &lt; self.data.len()) }
    }

    pub fn new(data: &amp;[u8]) -&gt; Option&lt;S&gt; {
        match data.len() {
            0 =&gt; None,
            n =&gt; {
                let s = S{data: data, ofs: n - 1};
                s.check_invariant();
                Some(s)
            }
        }
    }

    pub fn get(&amp;self) -&gt; u8 {
        self.check_invariant();
        self.data[self.ofs]
    }
}

#[no_mangle]
pub extern "C" fn hello_world(s: &amp;S) -&gt; u8 {
    s.get()
}
</code></pre>  

<p>This makes use of
<a href="https://doc.rust-lang.org/std/hint/fn.assert_unchecked.html"><code>std::hint::assert_unchecked</code></a>,
a very sharp tool for making soundness promises to the compiler.  Here we use
it to inform the compiler of our struct invariant.  This has the desired effect
of making this “opt no-panic”:</p>



<p>This definitely requires care; we have to be very sure that the predicate we
pass to <code>assert_unchecked</code> is true.  Luckily we can fuzz against this assertion
to increase our confidence (in debug mode, <code>assert_unchecked</code> will panic if the
condition is not true).  Used judiciously, it can be a powerful tool for
explicitly expressing to Rust the invariants we were relying on to make index
operations safe in C.</p>

 Conclusion 

<p>No-Panic Rust is not for the faint of heart.  It requires a lot of careful,
detailed work, and forces you to give up some niceties of Rust, like the
standard library.  But if we are diligent, it can give us the performance, code
size, and error reporting behavior of a C library with the extra safety that
comes from Rust.</p>

<p>This extra safety comes from the fact that Rust will automatically insert
bounds checks anywhere it cannot prove that an access is safe.  This puts
the burden on us to justify to the compiler in every case why the bounds
check is safe to elide.  In some cases this will mean detecting a bounds
violation explictly and reporting the error to the caller (especially in
parsers, where we do not know whether the input is valid or not).  In other
cases, we may know through a program invariant that the index will always
be in-bounds, and we will need to communicate this invariant to Rust.</p>

<p>I should be clear that I have not yet attempted this technique at scale, so
I cannot report on how well it works in practice.  For now it is an exciting
future direction for upb, and one that I hope will pay off.</p>

<p>To make this technique practical, we need a tool that can diagnose where a
panic handler was reachable from.  The main technique we used in this article
(looking at binary size) does not give us any information about where a panic
came from.  On macOS, the <code>-why_live</code> linker option is perfect for this.  I
hope other linkers like LLD will add support for this option also.  If not, a
standalone tool could be written that analyzes a binary after it’s linked to
find the chain of references that lead to a panic handler.</p>

<p>It would be nice if Rust made it easier to stay within the no-panic subset.
It’s clear that writing no-panic code is not a core use case that the language
focuses on, but there are many situations (embedded, Linux Kernel, etc) where
we want to avoid panics.  It would be nice if functions or even crates could
advertise themselves as no-panic and have the compiler enforce this
transitively.  Changing a function from no-panic to panicking would then be an
API-breaking change.</p>
 
  <ol>
    <li>
      <p>There is some interesting discussion in <a href="https://internals.rust-lang.org/t/enforcing-no-std-and-no-panic-during-build/14505">Enforcing no-std and no-panic
  during
  build</a>,
  which links to some relevant Linux kernel mailing list threads.  Another
  interesting thread is <a href="https://users.rust-lang.org/t/negative-views-on-rust-panicking/69796">Negative view on Rust: panicking</a>.&nbsp;<a>↩</a></p>
    </li>
    <li>
      <p>If we are willing to go <a href="https://docs.rust-embedded.org/book/intro/no-std.html"><code>#![no_std]</code></a>,
  we can mitigate this code size overhead by writing our own
  <a href="https://doc.rust-lang.org/nomicon/panic-handler.html">panic handler</a>,
  which we could engineer to be much smaller than the std one.
  This does address the code size concern, but it does not compose
  well, as there can only be one panic handler for an entire binary,
  so it doesn’t make sense for a library to provide one.&nbsp;<a>↩</a></p>
    </li>
    <li>
      <p>Some Rust panics can technically be caught with <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html">catch_unwind</a>,
  but this is full of caveats and is not designed as an error recovery
  mechanism.&nbsp;<a>↩</a></p>
    </li>
    <li>
      <p>We choose <code>cdylib</code> instead of <code>staticlib</code> for this exercise, because
  <code>cdylib</code> will invoke the linker to produce a <code>.so</code>. This will
  perform a garbage-collection pass that discards unreachable code,
  so that we only count code that would actually get pulled in if
  you statically linked the library into a binary.&nbsp;<a>↩</a></p>
    </li>
    <li>
      <p>There are some crates specifically designed to test directly for
  the no-panic condition, including
  <a href="https://docs.rs/no-panic/latest/no_panic/">no_panic</a>,
  <a href="https://docs.rs/panic-never/latest/panic_never/">panic_never</a>, and
  <a href="https://docs.rs/no-panics-whatsoever/latest/no_panics_whatsoever/">no_panics_whatsoever</a>.
  None of them are ideal for our purposes (the second two are only for
  binaries, not libraries, and the first has to be applied to every
  relevant function individually), and anyway none of them are
  available in Godbolt.  These generally work by trying to create
  linker errors if the panic handler is linked in.&nbsp;<a>↩</a></p>
    </li>
    <li>
      <p>Unfortunately this does not appear to work with the nightly Rust
  compiler.  On nightly, <a href="https://godbolt.org/z/r8WvG6GeK">the resulting binary is &gt;300Kb</a>,
  indicating that the panic runtime was linked in.  This seems like a
  regression, and I have not been able to diagnose why this is.&nbsp;<a>↩</a></p>
    </li>
  </ol>
 

   

 

       
     

     

   

     
       
        <ul>
          <li>Josh Haberman</li>
          <li><a href="mailto:jhaberman@gmail.com">jhaberman@gmail.com</a></li>
        </ul>
       

       
        <ul>
          
          <li>
            <a href="https://github.com/haberman">
haberman</a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/JoshHaberman">
JoshHaberman</a>

          </li>
          
        </ul>
       

       
        <p>Parsing, performance, and low-level programming.</p>
       
     

   

 


  


